1. 禁用`List`中的拷贝构造和拷贝赋值，且需要显示定义默认构造函数；另外再增加一个重载版本的`insert`：
```cpp
template <typename T>
class List : public Object
{
public:
    List() = default; // C++11  由于禁用了拷贝构造和拷贝赋值，相当于将它们定义为private/protected的，此时编译器不会自动生成别的构造函数，需要自定义默认的构造函数。
    virtual bool insert(const T& e) = 0;
    virtual bool insert(int i, const T& e) = 0;
    virtual bool remove(int i) = 0;
    virtual bool set(int i, const T& e) = 0;
    virtual bool get(int i, T& e) const = 0;
    virtual int length() const = 0;
    virtual void clear() = 0;
    List(const List& rhs) = delete; // C++11   禁用拷贝构造
    List& operator=(const List& rhs) = delete; // 禁用拷贝赋值
};
```

2. `insert`这个纯虚函数在其子类中实现：
```cpp
bool insert(const T& e)
{
    return insert(m_length, e);
}
```

3. 线性表必须先插入元素，才能用`[]`去访问里面的元素，不能把线性表当作数组使用，例如：
```cpp
int main()
{
    StaticList<int, 5> list;

    for(int i = 0; i < list.capacity(); i++)
    {
        list[i] = i*i;
    }

    return 0;
}
```

这样会发生越界错误，因为插入操作判断越界是和`m_length`对比，没插入元素的时候`m_length = 0`.