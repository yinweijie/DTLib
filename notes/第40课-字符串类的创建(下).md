1. 增加括号操作符重载函数，有两个版本，即`const`版本和非`const`版本，非`const`版本的可以被赋值，因此返回的是**引用类型**

接口为：
```cpp
char& operator[](int i);
char operator[](int i) const;
```
定义为：
```cpp
char& String::operator[](int i)
{
    if(0 <= i && i < m_length)
    {
        return m_str[i];
    }
    else
    {
        THROW_EXCEPTION(IndexOutOfBoundsException, "Parameter i is invalid ...");
    }
}

char String::operator[](int i) const
{
    return (const_cast<String&>(*this))[i];
}
```

注意判断插入位置的合法性。

2. 判断是否以指定字符串开始或结束

需要依次对比每个字符，这个过程如下图所示：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200531183325.png)

接口为；
```cpp
bool startWith(const char* s) const;
bool startWith(const String& s) const;
bool endOf(const char* s) const;
bool endOf(const String& s) const;
```
其中，封装对比函数：
```cpp
bool String::equal(const char* l, const char* r, int len) const
{
    bool ret = true;

    for(int i = 0; i < len && ret; i++)
    {
        ret = ret && (l[i] == r[i]);
    }

    return ret;
}
```

定义为：
```cpp
bool String::startWith(const char* s) const
{
    bool ret = (s != nullptr);

    if(ret)
    {
        int len = strlen(s);

        ret = (len < m_length) && equal(m_str, s, len);
    }

    return ret;
}

bool String::startWith(const String& s) const
{
    return startWith(s.m_str);
}

bool String::endOf(const char* s) const
{
    bool ret = (s != nullptr);

    if(ret)
    {
        int len = strlen(s);
        char* str = m_str + (m_length - len);

        ret = (len < m_length) && equal(str, s, len);
    }

    return ret;
}

bool String::endof(const String& s) const
{
    return endOf(s.m_str);
}

```

3. 在指定位置处插入字符串

一共分三步：当插入位置为`i`，则把前`i`个字符拷贝到新的空间中；然后要插入的字符拷贝到其后；最后把原字符的后`m_length - i`个字符拷贝到最后，并以`\0`结尾。该过程示意图为：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200531184802.png)

接口为：
```cpp
String& insert(int i, const char* s);
String& insert(int i, const String& s);
```

定义为：
```cpp
String& String::insert(int i, const char* s)
{
    if((0 <= i) && (i <= m_length))
    {
        if((s != nullptr) && (s[0] != '\0'))
        {
            int len = strlen(s);
            char* str = reinterpret_cast<char*>(malloc(m_length + len + 1));

            if(str)
            {
                strncpy(str, m_str, i);
                strncpy(str + i, s, len);
                strncpy(str + i + len, m_str + i, m_length - i);

                str[m_length + len] = '\0';

                free(m_str);
                m_str = str;
                m_length = m_length + len;
            }
            else
            {
                THROW_EXCEPTION(NoEnoughMemoryException, "No memory to insert string value ...");
            }
        }
    }
    else
    {
        THROW_EXCEPTION(IndexOutOfBoundsException, "Parameter i is invalid ...");
    }

    return *this;
}

String& String::insert(int i, const String& s)
{
    return insert(i, s.m_str);
}
```

4. 去掉字符串两端的空白字符

需要把去掉首尾空字符后的字符串，拷贝到字符串开头，示意图为：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200531185947.png)

接口为：
```cpp
String& trim();
```

定义为：
```cpp
String& String::trim()
{
    int b = 0;
    int e = m_length - 1;

    while(m_str[b] == ' ') b++;
    while(m_str[e] == ' ') e--;

    if(b == 0)
    {
        m_str[e + 1] = '\0';
        m_length = e + 1;
    }
    else
    {
        for(int i = 0, j = b; j <= e; i++, j++)
        {
            m_str[i] = m_str[j];
        }

        m_str[e - b + 1] = '\0';
        m_length = e - b + 1;
    }

    return *this;
}
```