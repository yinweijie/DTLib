对于树结构，想要遍历查找每个节点，需要递归其子节点：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200611220125.png)

1. 增加两个`find`函数，分别是基于值寻找节点和基于节点寻找节点：
   
算法描述为：
- 基于值寻找节点
![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200611220257.png)
- 基于节点寻找节点
![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200611220412.png)

代码为：

```cpp
template <typename T>
class GTree : public Tree<T>
{
protected:
    GTreeNode<T>* find(GTreeNode<T>* node, T value) const
    {
        GTreeNode<T>* ret = nullptr;

        if(node != nullptr)
        {
            if(node->value == value)
            {
                return node; // 如果找到了，直接返回
            }

            // 循环链表中的子节点
            for(node->child.move(0); (!node->child.end()) && (ret == nullptr); node->child.next())
            {
                ret = find(node->child.current(), value);
            }
        }

        return ret;
    }

    GTreeNode<T>* find(GTreeNode<T>* node, GTreeNode<T>* obj) const
    {
        GTreeNode<T>* ret = nullptr;

        if(node == obj)
        {
            return node;
        }

        if(node != nullptr)
        {
            for(node->child.move(0); (!node->child.end()) && (ret == nullptr); node->child.next())
            {
                ret = find(node->child.current(), obj);
            }
        }

        return ret;
    }
public:
    ...

    GTreeNode<T>* find(const T& value) const override
    {
        return find(root(), value);
    }

    GTreeNode<T>* find(TreeNode<T>* node) const override
    {
        // 注意需要进行强制类型转换
        return find(root(), dynamic_cast<GTreeNode<T>*>(node));
    }

    GTreeNode<T>* root() const override
    {
        return dynamic_cast<GTreeNode<T>*>(this->m_root);
    }

    ...
};
```