1. 设计遍历树中节点的方法

- 原料：`LinkQueue<GTreeNode<T>*>`;
- 游标：`LinkQueue<T>::front()`;
- 思想:
    - `begin()`$\rightarrow$将根结点压入队列中
    - `current()`$\rightarrow$访问队头元素指向的数据元素
    - `next()`$\rightarrow$队头元素弹出,将队头元素的孩子压入队列中(核心)
    - `end()`$\rightarrow$判断队列是否为空

代码实现：

`GTree.h`
```cpp
protected:
    LinkQueue<GTreeNode<T>*> m_queue;

public:
    bool begin()
    {
        bool ret = (root() != nullptr);

        if(ret)
        {
            m_queue.clear();
            m_queue.add(root()); // 遍历树节点的第一步需要先将根节点加入到m_queue中
        }

        return ret;
    }

    T current()
    {
        if(!end())
        {
            return (m_queue.front()->value); // 返回队列前端的元素GTreeNode中包含的值
        }
        else
        {
            THROW_EXCEPTION(InvalidOperationException, "No value at current position ...");
        }
    }

    bool next()
    {
        bool ret = (m_queue.length() > 0);

        if(ret)
        {
            GTreeNode<T>* node = m_queue.front();
            m_queue.remove(); // 取出队列第一个元素

            for(node->child.move(0); !node->child.end(); node->child.next()) // 将该元素的子节点加入队列末尾
            {
                m_queue.add(node->child.current());
            }
        }

        return ret;
    }

    bool end()
    {
        return (m_queue.length() == 0);
    }
```

需要做出修改的地方：

`GTree.h`
```cpp
private:
    GTree(const GTree<T>& rhs) = delete;

    GTree& operator=(const GTree<T>& rhs) = delete;
public:
    GTree() = default; // 由于给出了拷贝构造，因此不会自动生成默认构造函数，需要显式定义

    SharedPointer<Tree<T>> remove(const T& value) override
    {
        GTree<T>* ret = nullptr;
        GTreeNode<T>* node = find(value);

        if(node != nullptr)
        {
            remove(node, ret);
            m_queue.clear(); // 树结构发生了变化，需要清空m_queue
        }
        else
        {
            THROW_EXCEPTION(InvalidParameterException, "Cannot find the node via value parameter ...");
        }

        return ret;
    }

    SharedPointer<Tree<T>> remove(TreeNode<T>* node) override
    {
        GTree<T>* ret = nullptr;

        node = find(node);

        if(node != nullptr)
        {
            remove(dynamic_cast<GTreeNode<T>*>(node), ret);
            m_queue.clear();
        }
        else
        {
            THROW_EXCEPTION(InvalidParameterException, "Cannot find the node via node parameter ...");
        }

        return ret;
    }

    void clear() override
    {
        free(root());
        this->m_root = nullptr;
        m_queue.clear();
    }
```

`GTreeNode.h`
```cpp
GTreeNode(const GTreeNode<T>& rhs) = delete;

GTreeNode& operator=(const GTreeNode<T>& rhs) = delete;
```

遍历操作：

```cpp
for(tree.begin(); !tree.end(); tree.next())
{
    cout << tree.current() << endl;
}
```