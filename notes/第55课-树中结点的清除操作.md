1. 节点清除操作

清除节点是一个递归操作，需要递归删除其节点的每个子节点，然后再删除自身，算法描述如下：
![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200614000936.png)

```cpp
protected:
...

void free(GTreeNode<T>* node)
{
    if(node != nullptr)
    {
        // 需要注意的是，这里将子节点传入free后，最终会被delete掉，但是并不会调用child链表的remove操作
        for(node->child.move(0); !node->child.end(); node->child.next())
        {
            free(node->child.current());
        }

        if(node->flag()) // 后面介绍到的工厂方法，只对堆区生成的节点使用delete操作
        {
            delete node;
        }
    }
}

public:
...

void clear() override
{
    free(root()); // 删除整个树
    this->m_root = nullptr;
}
```

2. 工厂模式

在清除节点的时候，如果直接`delete`，就有可能对栈区创建的对象做出`delete`操作，例如：

```cpp
GTreeNode<char> root;
root.value = 'A';
root.parent = nullptr;

tree.insert(&root);
```

因此需要做如下更改：

- 在`GTreeNode`中增加保护成员变量`m_flag`，只有堆区对象才标记为`true`
- 将`GTreeNode`中的`operator new`重载为保护成员函数，只允许调用工厂方法生成堆对象，不允许直接`new`
- 提供工厂方法`GTreeNode<T>* NewNode()`，用该方法创建的对象`m_flag`为真
- 在工厂方法中`new`新结点并将`m_flag`设置为`true`

`GTreeNode`类修改为：
```cpp
template <typename T>
class GTreeNode : public TreeNode<T>
{
protected:
    bool m_flag;

    void* operator new(unsigned int size) noexcept
    {
        return Object::operator new(size);
    }
public:
    LinkList<GTreeNode<T>*> child;

    GTreeNode()
    {
        m_flag = false;
    }

    bool flag()
    {
        return m_flag;
    }

    static GTreeNode<T>* NewNode()
    {
        GTreeNode<T>* ret = new GTreeNode();

        if(ret != nullptr)
        {
            ret->m_flag = true;
        }

        return ret;
    }
};
```

`GTree`的`insert`函数中，生成堆节点不应该用

```cpp
GTreeNode<T>* node = GTreeNode<T>();
```

应该用：

```cpp
GTreeNode<T>* node = GTreeNode<T>::NewNode();
```

`GTree`中的`free`函数在`delete`节点时，需要增加一个判断：

```cpp
if(node->flag())
{
    delete node;
}
```