#1 用栈实现队列

实现思路：

- 准备两个栈用于实现队列:`stack_in`和`stack_out`
    - 当有新元素入队时：
      - 将其压入`stack_in`
    - 当需要出队时：
        - `if stack_out.size() == 0`:
    将`stack_in`中的元素逐一弹出并压入`stack_out`
    将`stack_out`的栈顶元素弹出
        - `if stack_out.size() > 0`:
    将`stack_out`的栈顶元素弹出

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200527180814.png)

```cpp
template <typename T>
class StackToQueue : public Queue<T>
{
protected:
    mutable LinkStack<T> m_stack_in;
    mutable LinkStack<T> m_stack_out;

    void move() const // O(n)
    {
        if(m_stack_out.size() == 0)
        {
            while(m_stack_in.size() > 0)
            {
                m_stack_out.push(m_stack_in.top());
                m_stack_in.pop();
            }
        }
    }
public:
    void add(const T& e) override // O(1)
    {
        m_stack_in.push(e);
    }

    void remove() override // O(n)
    {
        move();

        if(m_stack_out.size() > 0) {
            m_stack_out.pop();
        }
        else
        {
            THROW_EXCEPTION(InvalidOperationException, "No element in current queue ...");
        }
    }

    T front() const override // O(n)
    {
        move();

        if(m_stack_out.size() > 0) {
            return  m_stack_out.top();
        }
        else
        {
            THROW_EXCEPTION(InvalidOperationException, "No element in current queue ...");
        }
    }
    void clear() override // O(n)
    {
        m_stack_in.clear();
        m_stack_out.clear();
    }

    int length() const override // O(n)
    {
        return m_stack_in.size() + m_stack_out.size();
    }
};
```

# 2 用队列实现栈

实现思路：

- 准备两个队列用于实现栈：`queue_1[in]`和`queue_2[out]`
    - 当有新元素入栈时：
        - 将其加入队列`[in]`
    - 当需要出栈时：
        - 将队列`[in]`中的`n-1`个元素出队列,并进入队列`[out]`中
        - 将队列`[in]`中的最后一个元素出队列(出栈)
        - 交换两个队列的角色：`queue_1[out]`和`queue_2[in]`

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200527180933.png)

```cpp
template <typename T>
class QueueToStack : public Stack<T>
{
protected:
    LinkQueue<T> m_queue_1;
    LinkQueue<T> m_queue_2;
    LinkQueue<T>* m_pIn;
    LinkQueue<T>* m_pOut;

    void move() const // O(n)
    {
        int n = m_pIn->length() - 1;

        for(int i = 0; i < n; i++)
        {
            m_pOut->add(m_pIn->front()); // const QueueToStack<T>* this ==> LinkQueue<T>* const (this->m_pOut)
            m_pIn->remove();
        }
    }

    void swap() // O(1)
    {
        LinkQueue<T>* tmp = nullptr;

        tmp = m_pIn;
        m_pIn = m_pOut;
        m_pOut = tmp;
    }
public:
    QueueToStack() // O(1)
    {
        m_pIn = &m_queue_1;
        m_pOut = &m_queue_2;
    }

    void push(const T& e) override // o(1)
    {
        m_pIn->add(e);
    }

    void pop() override // O(n)
    {
        if(m_pIn->length() > 0)
        {
            move();

            m_pIn->remove();

            swap();
        }
        else
        {
            THROW_EXCEPTION(InvalidOperationException, "No element in current queue ...");
        }
    }
    T top() const override // O(n)
    {
        if(m_pIn->length() > 0)
        {
            move(); // move一次以后m_pIn指向的队列中只有一个元素，即使再调用一次move，由于每次只移动n-1个元素，m_pIn指向的元素也不再被移动

            return  m_pIn->front();
        }
        else
        {
            THROW_EXCEPTION(InvalidOperationException, "No element in current queue ...");
        }
    }

    void clear() override // O(n)
    {
        m_queue_1.clear();
        m_queue_2.clear();
    }

    int size() const override // O(1)
    {
        return m_queue_1.length() + m_queue_2.length();
    }
};
```