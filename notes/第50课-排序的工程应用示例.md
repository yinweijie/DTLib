1. 排序类(`Sort`)与数组类(`Array`)的关系

排序算法传入的对象为原生数组，对于自定义的`Array`类需要重载排序函数，首先在`Array`抽象基类中添加函数：

```cpp
T* array() const
{
    return m_array;
}
```
该函数用来返回`Array`对象维护的数组空间。

接下来在`Sort`类中添加函数：

```cpp
template <typename T>
static void Selection(Array<T>& array, bool min2max = true)
{
    Selection(array.array(), array.length(), min2max);
}

template <typename T>
static void Insert(Array<T>& array, bool min2max = true)
{
    Insert(array.array(), array.length(), min2max);
}

template <typename T>
static void Bubble(Array<T>& array, bool min2max = true)
{
    Bubble(array.array(), array.length(), min2max);
}

template <typename T>
static void Shell(Array<T>& array, bool min2max = true)
{
    Shell(array.array(), array.length(), min2max);
}

template <typename T>
static void Merge(Array<T>& array, bool min2max = true)
{
    Merge(array.array(), array.length(), min2max);
}

template <typename T>
static void Quick(Array<T>& array, bool min2max = true)
{
    Quick(array.array(), array.length(), min2max);
}
```
可以看到复用了之前定义的排序函数，并把`array.array()`返回的指针传进去。

2. 大对象的排序--代理类

排序过程中，如果对象非常大，在调用`Swap`函数的时候，拷贝过程会非常耗时，可以定义一个代理类，类中维护对应对象的指针类型，排序的时候，排序这个代理对象即可，由于代理对象中只有一个指针变量，因此效应高很多，示意图为：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200610163512.png)

代码：

```cpp
struct Test : public Object
{
    int id;
    int data1[1000]; // Test类中的内容非常多，直接拷贝非常耗时
    double data2[500];

    bool operator>(const Test& rhs)
    {
        return (id > rhs.id);
    }

    bool operator<=(const Test& rhs)
    {
        return (id <= rhs.id);
    }

    bool operator<(const Test& rhs)
    {
        return (id < rhs.id);
    }

    bool operator>=(const Test& rhs)
    {
        return (id >= rhs.id);
    }
};

class TestProxy : public Object
{
protected:
    Test* m_pTest; // 代理类中维护一个指向Test类的指针
public:
    Test& operator=(Test& test) // 用原始对象给代理对象赋值
    {
        m_pTest = &test;

        return test;
    }

    Test& Test() const // 方便代理类获取对象
    {
        return *m_pTest;
    }

    int id() const
    {
        return m_pTest->id;
    }

    int* data1() const
    {
        return m_pTest->data1;
    }

    double* data2() const
    {
        return m_pTest->data2;
    }

    bool operator>(const TestProxy& rhs) // 进入排序算法中进行比较的对象是TestProxy
    {
        return (Test() > rhs.Test()); // 比较的基准是所指向对象的大小
    }

    bool operator<=(const TestProxy& rhs)
    {
        return (Test() <= rhs.Test());
    }

    bool operator<(const TestProxy& rhs)
    {
        return (Test() < rhs.Test());
    }

    bool operator>=(const TestProxy& rhs)
    {
        return (Test() >= rhs.Test());
    }
};
```