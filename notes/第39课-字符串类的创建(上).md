1. 创建字符串类`String`，文件名不能是`String.h`，否则可能出现编译错误，推测是和库函数名冲突。

类接口为：

```cpp
class String : public Object
{
protected:
    char* m_str;
    int m_length;

    void init(const char* s);
public:
    String();
    String(char c);
    String(const char* s);
    String(const String& s);

    int length() const;
    const char* str() const;

    bool operator==(const String& s) const;
    bool operator==(const char* s) const;
    bool operator!=(const String& s) const;
    bool operator!=(const char* s) const;
    bool operator>(const String& s) const;
    bool operator>(const char* s) const;
    bool operator<(const String& s) const;
    bool operator<(const char* s) const;
    bool operator>=(const String& s) const;
    bool operator>=(const char* s) const;
    bool operator<=(const String& s) const;
    bool operator<=(const char* s) const;

    String operator+(const String& s) const;
    String operator+(const char* s) const;
    String& operator+=(const String& s);
    String& operator+=(const char* s);

    String& operator=(const String& s);
    String& operator=(const char* s);
    String& operator=(char c);

    ~String();
};
```

类实现：

```cpp
void String::init(const char* s)
{
    m_str = strdup(s); // 这个函数用到了malloc，因此需要free去释放

    if(m_str)
    {
        m_length = strlen(s);
    }
    else
    {
        THROW_EXCEPTION(NoEnoughMemoryException, "No memory to create String object ...");
    }
}

String::String()
{
    init("");
}

String::String(char c)
{
    char s[] = {c, '\0'};

    init(s);
}

String::String(const char* s)
{
    init(s ? s : ""); // 有可能传过来一个nullptr，需要把nullptr转换成空字符串
}

String::String(const String& s)
{
    init(s.m_str);
}

int String::length() const
{
    return m_length;
}

const char* String::str() const
{
    return m_str;
}

bool String::operator==(const String& s) const
{
    return (strcmp(m_str, s.m_str) == 0);
}

bool String::operator==(const char* s) const
{
    return (strcmp(m_str, s ? s : "") == 0);
}

bool String::operator!=(const String& s) const
{
    return !(*this == s);
}

bool String::operator!=(const char* s) const
{
    return !(*this == s);
}

bool String::operator>(const String& s) const
{
    return (strcmp(m_str, s.m_str) > 0);
}

bool String::operator>(const char* s) const
{
    return (strcmp(m_str, s ? s : "") > 0);
}

bool String::operator<(const String& s) const
{
    return (strcmp(m_str, s.m_str) < 0);
}

bool String::operator<(const char* s) const
{
    return (strcmp(m_str, s ? s : "") < 0);
}

bool String::operator>=(const String& s) const
{
    return (strcmp(m_str, s.m_str) >= 0);
}

bool String::operator>=(const char* s) const
{
    return (strcmp(m_str, s ? s : "") >= 0);
}

bool String::operator<=(const String& s) const
{
    return (strcmp(m_str, s.m_str) <= 0);
}

bool String::operator<=(const char* s) const
{
    return (strcmp(m_str, s ? s : "") <= 0);
}

String String::operator+(const String& s) const
{
    return (*this + s.m_str); // 复用operator+(const char* s)
}

String String::operator+(const char* s) const
{
    String ret;
    int len = m_length + strlen(s ? s : "");
    char* str = reinterpret_cast<char*>(malloc(len + 1));

    if(str)
    {
        strcpy(str, m_str);
        strcat(str, s ? s : "");

        free(ret.m_str); // 新建立的String对象，指向空字符串，用到了strdup函数，是用malloc去创建的字符串

        ret.m_str = str;
        ret.m_length = len;
    }
    else
    {
        THROW_EXCEPTION(NoEnoughMemoryException, "No memory to add string ...");
    }
    return ret;
}

String& String::operator+=(const String& s)
{
    return (*this = *this + s.m_str); // 复用operator+(const char* s)和operator=(const char* s)
}

String& String::operator+=(const char* s)
{
    return (*this = *this + s); // 复用operator+(const char* s)和operator=(const char* s)
}

String& String::operator=(const String& s)
{
    return (*this = s.m_str); // 复用operator=(const char* s)
}

String& String::operator=(const char* s)
{
    if(m_str != s)
    {
        char* str = strdup(s ? s : "");

        if(str)
        {
            free(m_str);

            m_str = str;
            m_length = strlen(m_str);
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException, "No memory to assign new string ...");
        }
    }

    return (*this);
}

String& String::operator=(char c)
{
    char s[] = {c, '\0'};

    return (*this = s); // 复用operator=(const char* s)
}

String::~String()
{
    free(m_str);
}
```