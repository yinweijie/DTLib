1. 定义枚举类型，用来标识插入到节点的左边还是右边

定义在`namespace DTLib`中：

```cpp
enum BTNodePos
{
    ANY,
    LEFT,
    RIGHT
};
```

2. 定义`protected`的`insert`虚函数

该函数传入节点地址，节点的父节点，以及插入位置（在父节点左边还是右边）：

```cpp
protected:
    virtual bool insert(BTreeNode<T>* n, BTreeNode<T>* np, BTNodePos pos)
    {
        bool ret = true;

        if(pos == ANY) // 如果父节点的左孩子为空就插入到左边，如果右孩子为空，就插入到右边，如果都不为空则返回false
        {
            if(np->left == nullptr)
            {
                np->left = n;
            }
            else if(np->right == nullptr)
            {
                np->right = n;
            }
            else
            {
                ret = false;
            }
        }
        else if(pos == LEFT) // 看左边是否为空，为空就插入
        {
            if(np->left == nullptr)
            {
                np->left = n;
            }
            else
            {
                ret = false;
            }
        }
        else if(pos == RIGHT)
        {
            if(np->right == nullptr)
            {
                np->right = n;
            }
            else
            {
                ret = false;
            }
        }
        else
        {
            ret = false;
        }

        return ret;
    }
```

3. 定义`public`的`insert`虚函数，插入新节点

```cpp
public:
    bool insert(TreeNode<T>* node) override // 将节点插入任意位置
    {
        return insert(node, ANY);
    }

    virtual bool insert(TreeNode<T>* node, BTNodePos pos) // 将节点插入指定位置，先找到node的父节点，然后插入
    {
        bool ret = true;

        if(node != nullptr)
        {
            if(this->m_root == nullptr)
            {
                this->m_root = node;
                node->parent = nullptr;
            }
            else
            {
                BTreeNode<T>* np = find(node->parent);

                if(np != nullptr)
                {
                    ret = insert(dynamic_cast<BTreeNode<T>*>(node), np, pos);
                }
                else
                {
                    THROW_EXCEPTION(InvalidOperationException, "Invalid parent tree node ...");
                }
            }
        }
        else
        {
            THROW_EXCEPTION(InvalidParameterException, "Parameter cannot be NULL ...");
        }

        return ret;
    }

    bool insert(const T& value, TreeNode<T>* parent) override // 将元素插入任意位置
    {
        return insert(value, parent, ANY);
    }

    virtual bool insert(const T& value, TreeNode<T>* parent, BTNodePos pos) // 将元素插入指定位置，先利用元素构造节点，然后将节点插入
    {
        bool ret = true;
        BTreeNode<T>* node = BTreeNode<T>::NewNode();

        if(node != nullptr)
        {
            node->value = value;
            node->parent = parent;

            ret = insert(node, pos);

            if(ret != true)
            {
                delete node; // GTree可以插入任意多个节点，而BTree每个节点后只能插入两个节点，因此有可能插入失败，如果插入失败就需要delete这个额外定义的堆对象
            }
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException, "No memory to create new tree node..");
        }

        return ret;
    }
```