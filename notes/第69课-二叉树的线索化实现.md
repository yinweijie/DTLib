1. 定义新的重载`traversal`函数，除了接收`order`参数，还接收`queue`参数。重构原来的`traversal`函数

重构后的函数为：

```cpp
private:
    void traversal(BTTraversal order, LinkQueue<BTreeNode<T>*>& queue)
    {
        switch(order)
        {
        case PreOder:
            preOrderTraversal(root(), queue);
            break;
        case InOrder:
            inOrderTraversal(root(), queue);
            break;
        case PostOrder:
            postOrderTraversal(root(), queue);
            break;
        case LevelOrder:
            levelOrderTraversal(root(), queue);
            break;
        default:
            THROW_EXCEPTION(InvalidParameterException, "Parameter order is invalid ...");
            break;
        }
    }

...

public:
    SharedPointer<Array<T>> traversal(BTTraversal order)
    {
        DynamicArray<T>* ret = nullptr;
        LinkQueue<BTreeNode<T>*> queue;

        traversal(order, queue);

        ret = new DynamicArray<T>(queue.length());

        if(ret != nullptr)
        {
            for(int i = 0; i < ret->length(); i++)
            {
    //            (*ret)[i] = queue.front()->value;
                ret->set(i, queue.front()->value);
                queue.remove();
            }
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException, "No memory to create return array ...");
        }

        return ret;
    }
```
2. 增加层次遍历函数`levelOrderTraversal`；增加`enum`类型`LevelOrder`

实现思路为，利用两个队列，其中`tmp`队列不断将队首的叶子节点压入队列中，与此同时不断将队首元素弹出，压入到队列`queue`中，代码实现为：

```cpp
private:
    void levelOrderTraversal(BTreeNode<T>* node, LinkQueue<BTreeNode<T>*>& queue)
    {
        if(node != nullptr)
        {
            LinkQueue<BTreeNode<T>*> tmp;

            tmp.add(node);

            while(tmp.length() > 0)
            {
                BTreeNode<T>* n = tmp.front();

                if(n->left != nullptr)
                {
                    tmp.add(n->left);
                }
                if(n->right != nullptr)
                {
                    tmp.add(n->right);
                }

                tmp.remove();
                queue.add(n);
            }
        }
    }

...

    void traversal(BTTraversal order, LinkQueue<BTreeNode<T>*>& queue)
    {
        switch(order)
        {
        case PreOder:
            preOrderTraversal(root(), queue);
            break;
        case InOrder:
            inOrderTraversal(root(), queue);
            break;
        case PostOrder:
            postOrderTraversal(root(), queue);
            break;
        case LevelOrder:
            levelOrderTraversal(root(), queue);
            break;
        default:
            THROW_EXCEPTION(InvalidParameterException, "Parameter order is invalid ...");
            break;
        }
    }
```
3. 增加线索化函数`thread`，将树结构变化为双向链表结构

由于递归遍历树的时候，递归过程比较耗时，因此如果需要反复遍历树的内容，可以把数结构根据遍历的类型（先序遍历、中序遍历、后序遍历、层次遍历），把数结构改为双向链表结构，函数实现过程为：

```cpp
public:
    BTreeNode<T>* thread(BTTraversal order)
    {
        BTreeNode<T>* ret = nullptr;

        LinkQueue<BTreeNode<T>*> queue;
        traversal(order, queue); // 节点指针被压入队列中
        ret = connect(queue); // 队列中的节点关系被改为双向链表

        this->m_root = nullptr; // 树结构不复存在，元素被以双向链表的形式保存下来
        this->m_queue.clear();

        return ret;
    }
```

其中，`connect`函数示意图为：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200629194849.png)

`connect`函数实现为：

```cpp
private:
    BTreeNode<T>* connect(LinkQueue<BTreeNode<T>*>& queue)
    {
        BTreeNode<T>* ret = nullptr;

        if(queue.length() > 0)
        {
            ret = queue.front();

            BTreeNode<T>* slider = queue.front();
            queue.remove();
            slider->left = nullptr;

            while(queue.length() > 0)
            {
                slider->right = queue.front();
                queue.front()->left = slider;
                slider = queue.front();
                queue.remove();
            }

            slider->right = nullptr;
        }

        return ret;
    }
```