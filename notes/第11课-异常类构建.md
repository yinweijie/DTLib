# 抽象基类注意事项

如果一个类里有纯虚函数，那么这个类就是抽象基类，抽象基类需要注意：

1. 抽象基类不能实例化
2. 抽象基类的子类必须要**重写所有**纯虚函数才能实例化
3. 各种**构造函数**都不能定义为纯虚函数
4. **析构函数**可以定义为纯虚函数，但是必须要在类外定义函数体
5. 子类如果没有定义析构函数，就会生成默认的析构函数，函数体为空，所以子类即使不写析构函数，纯虚析构函数也会发生重写。子类销毁的时候，会先调用自己的析构函数，再调用父类的析构函数，这也解释了为什么父类的析构函数即使是纯虚函数也要有函数体

示例：

```cpp
#include <iostream>

class B
{
public:
    B() { }
    virtual void f() = 0;
    virtual ~B() = 0; // 析构函数可以是纯虚函数
};

void B::f()
{
    std::cout << "B::f()" << std::endl;
}

B::~B() { // 但是必须有类外的函数体
    std::cout << "B::~B()" << std::endl;
}

class D : public B
{
public:
    void f() { } // 必须重写所有虚函数才能实例化D
    D() : B() { }
    ~D() { }
};

// D::~D() // 先调用自己的析构函数，再调用父类的析构函数
// {
//     std::cout << "D::~D()" << std::endl;
// }

int main()
{
    // B b; // 抽象基类不能实例化
    D d; // B::~B()   如果不定义析构函数，会生成默认析构函数，在对象析构的时候，会先调用自己的析构函数，再调用父类析构函数
    return 0;
}
```

# 异常类的设计

首先需要定义一个顶层抽象基类`Exception`，然后定义它的各个子类，也就是具体的异常类，其接口如下：

```cpp
namespace DTLib
{

class Exception
{
private:
    char* m_message;
    char* m_location;
public:
    Exception(const char* message, const char* location, int line);
    Exception(const char* location, int line);
    Exception(const char* message);

    Exception(const Exception& rhs);
    Exception& operator=(const Exception& rhs);

    virtual const char* message() const;
    virtual const char* location() const;

    virtual ~Exception() = 0;
};

}
```

需要注意，新添加的类的声明和定义都需要放在`namespace DTLib`中。

这个类维护两个字符串，因此需要注意进行深拷贝，以及析构函数中去释放空间。

子类的接口如下：

```cpp
namespace DTLib
{

class ArithmeticException : public Exception
{
public:
    ArithmeticException();
    ArithmeticException(const char* message, const char* location, int line);
    ArithmeticException(const char* location, int line);
    ArithmeticException(const char* message);

    ArithmeticException(const ArithmeticException& rhs);
    ArithmeticException& operator=(const ArithmeticException& rhs);

    ~ArithmeticException();
};

...

}
```

- 子类的构造函数中，要用初始化表的方式调用父类的构造函数去初始化从父类继承过来的对象；
- 子类的拷贝赋值函数，需要在函数体内调用父类的拷贝赋值函数；
- 由于子类还未定义自己的成员变量，因此析构函数体为空，在子类被销毁的时候，会先调用自己的析构函数，然后调用父类析构函数，销毁父类的成员。

# 至少留一个虚函数不要内联（定义在内外）

在定义子类析构函数的时候，由于函数体内为空，很自然的就在类内定义了，类内定义的函数默认内联编译，如果函数体内的虚函数全部内联编译，就会给出警告，此时虚函数表找不到应该被放在哪个`.cpp`文件中，就会每个`.cpp`文件都拷贝一份，使得`.o`文件变得臃肿。

参考：https://www.cnblogs.com/Vancamel/p/11781301.html