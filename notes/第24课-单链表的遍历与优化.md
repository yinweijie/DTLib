1. 优化遍历过程

现有的代码下，要遍历链表中的数据只能这么做：

```cpp
for(int i = 0; i < list.length(); i++)
{
    cout << list.get(i) << endl;
}
```

由于每次调用`get`都需要做链表的循环定位操作，因此整体的时间复杂度为$O(n^2)$，因此需要做优化。

| 函数        | 功能                       |
| ----------- | -------------------------- |
| `move()`    | 将游标定位到目标位置       |
| `next()`    | 移动游标                   |
| `current()` | 获取游标所指向的数据元素   |
| `end()`     | 游标是否到达尾部(是否为空) |

代码实现为：
```cpp
int m_step;
Node* m_current;

...

virtual bool move(int i, int step = 1)
{
    bool ret = (0 <= i) && (i < m_length) && (step > 0);

    if(ret)
    {
        m_current = position(i)->next;
        m_step = step;
    }

    return ret;
}

virtual bool end()
{
    return (m_current == nullptr);
}

virtual T current()
{
    if(!end())
    {
        return (m_current->value);
    }
    else
    {
        THROW_EXCEPTION(InvalidParameterException, "No value at current position ...");
    }
}

virtual bool next()
{
    int i = 0;

    while(i < m_step && !end())
    {
        m_current = m_current->next;
        i++;
    }

    return (i == m_step);
}
```

使用：
```cpp
for(l.move(0); !l.end(); l.next())
{
    cout << l.current() << endl;
}
```

2. `Node`对象的创建与销毁的封装

函数定义为：

```cpp
virtual Node* create()
{
    return new Node();
}

virtual void destroy(Node* pn)
{
    delete pn;
}
```

把`new Node()`和`delete`操作都用函数替换。