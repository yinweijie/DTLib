1. 二叉树的克隆

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200626150420.png)

```cpp
private:
    BTreeNode<T>* clone(BTreeNode<T>* node) const
    {
        BTreeNode<T>* ret = nullptr;

        if(node != nullptr)
        {
            ret = BTreeNode<T>::NewNode();

            if(ret != nullptr)
            {
                ret->value = node->value;
                ret->left = clone(node->left); // 拷贝左孩子节点，就会递归的拷贝左孩子的整个子树
                ret->right = clone(node->right);

                if(ret->left != nullptr) // 将左孩子的父节点设置为当前节点
                {
                    ret->left->parent = node;
                }
                if(ret->right != nullptr)
                {
                    ret->right->parent = node;
                }
            }
            else
            {
                THROW_EXCEPTION(NoEnoughMemoryException, "No memory to create new node ...");
            }
        }

        return ret;
    }

...

public:
    SharedPointer<BTree<T>> clone() const
    {
        BTree<T>* ret = new BTree<T>();

        if(ret != nullptr)
        {
            ret->m_root = clone(root());
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException, "No enough memory to create new tree ...");
        }

        return ret;
    }
```
2. 二叉树的比较

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200626150512.png)

```cpp
private:
    bool equal(BTreeNode<T>* lh, BTreeNode<T>* rh)
    {
        if(lh == rh) // nullptr == nullptr的时候，说明某一侧递归到叶子节点了，中途的节点都相等，返回true
        {
            return true;
        }
        else if(lh == nullptr && rh != nullptr) // 只要出现其中一个节点为空，另一个不为空，说明两个树不一样，返回false
        {
            return false;
        }
        else if(lh != nullptr && rh == nullptr)
        {
            return false;
        }

        return (lh->value == rh->value) && (equal(lh->left, rh->left)) && (equal(lh->right, rh->right));
    }

...

public:
    bool operator==(const BTree<T>& tree)
    {
        return equal(root(), tree.root());
    }

    bool operator!=(const BTree<T>& tree)
    {
        return !(*this == tree);
    }
```

3. 二叉树的相加

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200626150532.png)

```cpp
private:
    BTreeNode<T>* add(BTreeNode<T>* lh, BTreeNode<T>* rh) const
    {
        BTreeNode<T>* ret = nullptr;

        if(lh == nullptr && rh != nullptr)
        {
            ret = clone(rh); // 如果lh为空树，则两者相加结果为rh的拷贝
        }
        else if(lh != nullptr && rh == nullptr)
        {
            ret = clone(lh);
        }
        else if(lh != nullptr && rh != nullptr)
        {
            ret = BTreeNode<T>::NewNode();

            if(ret != nullptr)
            {
                ret->value = lh->value + rh->value;
                ret->left = add(lh->left, rh->left);
                ret->right = add(lh->right, rh->right);

                if(ret->left != nullptr)
                {
                    ret->left->parent = ret;
                }
                if(ret->right != nullptr)
                {
                    ret->right->parent = ret;
                }
            }
            else
            {
                THROW_EXCEPTION(NoEnoughMemoryException, "No memory to create new node ...");
            }
        }

        return ret;
    }

...

public:
    SharedPointer<BTree<T>> add(const BTree<T>& tree) const
    {
        BTree<T>* ret = new BTree<T>();

        if(ret != nullptr)
        {
            ret->m_root = add(this->root(), tree.root());
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException, "No memory to create new tree ...");
        }

        return ret;
    }
```