1. 归并排序

将数列一分为二，反复做这个动作，直到每部分只剩一个数字了，此时开始返回，每次返回时合并左右两个部分，且合并的时候依次将数字从小到大挑出来排序，大致过程如下：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200609211525.png)

算法实现过程：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200609212107.png)

归并的时候需要借助一个辅助空间，将左右两部分的内容依次拷贝到辅助空间中。

**注**：归并排序需要辅助空间才能完成，空间复杂度为$O(n)$，时间复杂度为$O(n\log n)$，是一种稳定的排序法。

代码实现为：

```cpp
class Sort : public Object
{
private:
    ...

    template <typename T>
    static void Merge(T src[], T helper[], int begin, int mid, int end, bool min2max)
    {
        int i = begin;
        int j = mid + 1;
        int k = begin;

        while((i <= mid) && (j <= end)) // 只要前后两部分，有一个到头了，就跳出循环，剩下的部分在后面的while循环中去操作
        {
            if(min2max ? (src[i] < src[j]) : (src[i] > src[j])) // 比较前后两个部分的值
            {
                helper[k++] = src[i++]; // 选出较小的，保存到辅助空间中，对于被选中的那个数，下标往后前进一位
            }
            else
            {
                helper[k++] = src[j++];
            }
        }

        while(i <= mid) // 循环i，j的时候，有可能其中一个先到达终点，另一个则全部紧接着放到辅助空间中
        {
            helper[k++] = src[i++];
        }

        while(j <= end)
        {
            helper[k++] = src[j++];
        }

        for(int i = begin; i <= end; i++) // 把排序好的部分重新拷贝到原始的数组中
        {
            src[i] = helper[i];
        }
    }

    template <typename T>
    static void Merge(T src[], T helper[], int begin, int end, bool min2max)
    {
        if(begin == end)
        {
            return;
        }

        int mid = (begin + end) / 2;

        Merge(src, helper, begin, mid, min2max); // 对前面一半进行归并排序
        Merge(src, helper, mid + 1, end, min2max); // 对后面一半进行归并排序
        Merge(src, helper, begin, mid, end, min2max); // 在前后两部分分各自排序好的基础上，做进一步的排序
    }

    ...

public:
    ...

    template <typename T>
    static void Merge(T array[], int n, bool min2max = true)
    {
        T* helper = new T[n]; // 辅助空间

        if(helper != nullptr)
        {
            Merge(array, helper, 0, n - 1, min2max);
        }

        delete[] helper;
    }

    ...
};
```

2. 快速排序

快速排序的基本思想是，先随便取一个数字（例如第一个数）的值作为pivot，分别从前往后和从后往前与基准数对比，如果后面的数小于基准数，则和前面的begin下标调换，如果前面的数大于基准数，则和后面的end下标调换，且每次更新begin和end的值，直到begin下标与end下标重合，此时的位置就是pivot的位置，示意图如下：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200609212942.png)

**注**：快速排序不需要辅助空间，时间复杂度为$O(n\log n)$，是一种不稳定的排序法。

代码实现为：

```cpp
class Sort : public Object
{
private:
    ...

    template <typename T>
    static int Partition(T array[], int begin, int end, bool min2max)
    {
        T pv = array[begin]; // 将第一个元素的值作为pivot

        while(begin < end) // 每次循环都做两次Swap操作
        {
            while((begin < end) && (min2max ? (array[end] > pv) : (array[end] < pv))) // 一次是将数组靠近尾部小于pivot的值与靠近头部的值交换
            {
                end--;
            }

            Swap(array[begin], array[end]);

            while((begin < end) && (min2max ? (array[begin] <= pv) : (array[begin] >= pv))) // 另一次是将数组靠近头部大于等于pivot的值与靠近尾部的值交换，上面和下面的while循环，有一个取等就可以了，如果都不取等，则只有在不等的时候才会往后或往前挪，如果前后都移到与pivot的值相等，就会出现死循环
            {
                begin++;
            }

            Swap(array[begin], array[end]);
        }

        array[begin] = pv; // 最终begin和end重合

        return begin;
    }

    template <typename T>
    static void Quick(T array[], int begin, int end, bool min2max)
    {
        if(begin < end)
        {
            int pivot = Partition(array, begin, end, min2max); // 先找到pivot的位置

            Quick(array, begin, pivot - 1, min2max); // 将pivot前面的数进一步进行Quick排序
            Quick(array, pivot + 1, end, min2max); // 将pivot后面的数进一步进行Quick排序
        }
    }

public:
    ...

    template <typename T>
    static void Quick(T array[], int n, bool min2max = true)
    {
        Quick(array, 0, n - 1, min2max);
    }
};
```
