1. 创建`BTree`和`BTreeNode`类

2. 将`GTreeNode`中的成员重构到`TreeNode`中，以便`BTreeNode`复用这部分代码，如下：

```cpp
protected:
    bool m_flag;

    GTreeNode(const GTreeNode<T>& rhs) = delete;

    GTreeNode& operator=(const GTreeNode<T>& rhs) = delete;

    void* operator new(unsigned int size) noexcept
    {
        return Object::operator new(size);
    }
```

3. 修改`TreeNode`的构造函数，让其初始化`m_flag`；修改`GTreeNode`为`TreeNode`；`flag()`函数移动到`TreeNode`中

最终`TreeNode`修改为：

```cpp
template <typename T>
class TreeNode : public Object
{
protected:
    bool m_flag;

    TreeNode(const TreeNode<T>& rhs) = delete;

    TreeNode& operator=(const TreeNode<T>& rhs) = delete;

    void* operator new(unsigned int size) noexcept
    {
        return Object::operator new(size);
    }
public:
    T value;
    TreeNode<T>* parent;

    TreeNode()
    {
        m_flag = false;
        parent = nullptr;
    }

    bool flag()
    {
        return m_flag;
    }

    virtual ~TreeNode() = 0;
};

template <typename T>
TreeNode<T>::~TreeNode()
{

}
```

4. 为`BTreeNode`增加`NewNode`工厂函数，左右孩子节点以及构造函数，用来初始化成员成员变量

类实现为：

```cpp
template <typename T>
class BTreeNode : public TreeNode<T>
{
public:
    BTreeNode<T>* left;
    BTreeNode<T>* right;

    BTreeNode()
    {
        left = nullptr;
        right = nullptr;
    }

    static BTreeNode<T>* NewNode()
    {
        BTreeNode<T>* ret = new BTreeNode();

        if(ret != nullptr)
        {
            ret->m_flag = true;
        }

        return ret;
    }
};
```

5. 将`GTree`中的成员重构到父类`Tree`中，如下：

```cpp
protected:
    GTree(const GTree<T>& rhs) = delete;

    GTree& operator=(const GTree<T>& rhs) = delete;
```

修改后类接口为：

```cpp
template <typename T>
class Tree : public Object
{
protected:
    TreeNode<T>* m_root;

    Tree(const Tree<T>& rhs) = delete;
    Tree& operator=(const Tree<T>& rhs) = delete;
public:
    Tree() { m_root = nullptr; }
    virtual bool insert(TreeNode<T>* node) = 0;
    virtual bool insert(const T& value, TreeNode<T>* parent) = 0;
    virtual SharedPointer<Tree<T>> remove(const T& value) = 0;
    virtual SharedPointer<Tree<T>> remove(TreeNode<T>* node) = 0;
    virtual TreeNode<T>* find(const T& value) const = 0;
    virtual TreeNode<T>* find(TreeNode<T>* node) const = 0;
    virtual TreeNode<T>* root() const = 0;
    virtual int degree() const = 0;
    virtual int count() const = 0;
    virtual int height() const = 0;
    virtual void clear() = 0;
};
```

6. 实现`BTree`中的纯虚函数框架

```cpp
template <typename T>
class BTree : public Tree<T>
{
public:
    bool insert(TreeNode<T>* node) override
    {
        bool ret = true;

        return ret;
    }

    bool insert(const T& value, TreeNode<T>* parent)
    {
        bool ret = true;

        return ret;
    }

    SharedPointer<Tree<T>> remove(const T& value)
    {
        return nullptr;
    }

    SharedPointer<Tree<T>> remove(TreeNode<T>* node)
    {
        return nullptr;
    }

    BTreeNode<T>* find(const T& value) const
    {
        return nullptr;
    }

    BTreeNode<T>* find(TreeNode<T>* node) const
    {
        return nullptr;
    }

    BTreeNode<T>* root() const
    {
        return dynamic_cast<BTreeNode<T>*>(this->m_root);
    }

    int degree() const
    {
        return 0;
    }

    int count() const
    {
        return 0;
    }

    int height() const
    {
        return 0;
    }

    void clear()
    {
        this->m_root = nullptr;
    }

    ~BTree()
    {
        clear();
    }
};
```