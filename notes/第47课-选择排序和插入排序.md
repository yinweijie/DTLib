1. 选择排序
- 选择排序每次选择未排元素中的最小元素
- 选择排序是不稳定的排序法
- 选择排序的时间复杂度为$O(n^2)$



2. 插入排序
- 插入排序每次将第$i$个元素插入前面$i-1$个已排元素中
- 插入排序是稳定的排序方法
- 插入排序的时间复杂度为$O(n^2)$

代码实现为：

```cpp
class Sort : public Object
{
private:
    Sort();
    Sort(const Sort& rhs);
    Sort& operator=(const Sort& rhs);

    template <typename T>
    static void Swap(T& a, T& b)
    {
        T c(a);
        a = b;
        b = c;
    }
public:
    template <typename T>
    static void Selection(T array[], int n, bool min2max = true)
    {
        for(int i = 0; i < n; i++)
        {
            int min = i; // 从i开始，往后找最小的元素，找到了最小的就和i交换，没有比i更小的就不交换
            for(int j = i + 1; j < n; j++)
            {
                if(min2max ? (array[min] > array[j]) : (array[min] < array[j]))
                {
                    min = j; // 标记最小元素的下标
                }
            }

            if(min != i) // 如果min == i，说明i后面没有更小的元素，此时不用交换
            {
                Swap(array[i], array[min]);
            }
        }
    }

    template <typename T>
    static void Insert(T array[], int n, bool min2max = true)
    {
        for(int i = 1; i < n; i++) // 第0个元素已经是排序好了的状态，所以从第1个元素开始
        {
            int k = i;
            T e = array[i]; // 把待插入元素拷贝一份

            for(int j = i - 1; (j >= 0) && (min2max ? (array[j] > e) : (array[j] < e)); j--)
            {
                array[j + 1] = array[j]; // 依次往前找是否有比待插入元素大的元素，如果有，就把这个元素往后挪一位，空出这个可能插入的位置
                k = j; // 标记可能插入的位置
            }

            if(k != i) // 如果k == i，说明前面没有比i大的元素，保持不动即可
            {
                array[k] = e; // 把元素i插入到前面合适的位置
            }
        }
    }
};
```