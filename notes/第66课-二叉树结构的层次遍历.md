1. 和`GTree`中遍历函数类似，定义四个函数`begin`, `current`, `next`, `end`，如下：

```cpp
public:
    bool begin() override
    {
        bool ret = (root() != nullptr);

        if(ret)
        {
            m_queue.clear();
            m_queue.add(root());
        }

        return ret;
    }

    T current() override
    {
        if(!end())
        {
            return (m_queue.front()->value);
        }
        else
        {
            THROW_EXCEPTION(InvalidOperationException, "No value at current position ...");
        }
    }

    bool next() override
    {
        bool ret = (m_queue.length() > 0);

        if(ret)
        {
            BTreeNode<T>* node = m_queue.front();
            m_queue.remove();

            if(node->left != nullptr) m_queue.add(node->left);
            if(node->right != nullptr) m_queue.add(node->right);
        }

        return ret;
    }

    bool end() override
    {
        return (m_queue.length() == 0);
    }
```

可以看到，只有`next`函数做了一些修改，其他的三个函数实现都和`GTree`中的一样。

除此以外，还需要在`clear`和`remove`函数中添加`m_queue.clear()`操作

2. 重构代码，将这四个函数在`Tree`中定义为纯虚函数，如下：

```cpp
public:
    virtual void clear() = 0;
    virtual bool begin() = 0;
    virtual T current() = 0;
    virtual bool next() = 0;
```