1. 在`Exception::init`中修改:

```cpp
m_message = strdup(message);
```

为：

```cpp
m_message = message ? strdup(message) : nullptr;
```

因为`strdup`这个标准库函数没有做空字符串的判断，如果传入空字符串，可能报错。

2. 在`LinkList::remove`中，将：

```cpp
destroy(toDel);
m_length--;
```

修改为：

```cpp
m_length--; // 先更新长度信息，再消耗对象，保证异常安全
destroy(toDel);
```

在做`remove`操作的时候，不管对象是否成功析构，都应该认为链表长度减小1，因此要把销毁对象操作放在最后，保证析构发生异常的时候，链表中元素个数是正确的。

3. 类似地，修改`LinkList::clear`中：

```cpp
void clear() override // O(n)
{
    while (m_header.next != nullptr)
    {
        Node* toDel = m_header.next;
        m_header.next = toDel->next;

        destroy(toDel);
    }

    m_length = 0;
}
```

为：

```cpp
void clear() override // O(n)
{
    while (m_header.next != nullptr)
    {
        Node* toDel = m_header.next;
        m_header.next = toDel->next;

        m_length--; // 先更新长度信息，再消耗对象，保证异常安全

        destroy(toDel);
    }
}
```

4. 如果删除元素正好为游标`m_current`所在位置，`m_current`将变成野指针，因此在删除`m_current`位置的元素后，要往后移动一下`m_current`，所以`LinkList::remove`修改为：

```cpp
bool remove(int i) override // O(n)
{
    bool ret = (0 <= i) && (i < m_length);

    if(ret)
    {
        Node* current = position(i);

        Node* toDel = current->next;
        current->next = toDel->next;

        if(m_current == toDel) // 如果删除的元素正好为游标m_current所在位置，就把m_current往后移一位
        {
            m_current = toDel->next;
        }

        m_length--; // 先更新长度信息，再消耗对象，保证异常安全

        destroy(toDel);
    }

    return ret;
}
```

这里增加了一个`if(m_current == toDel)`判断。

5. 函数`StaticLinkList::destroy`中的循环体，当寻找到了需要的位置后，就不需要继续循环了，代码修改为：

```cpp
void destroy(Node* pn)
{
    SNode* space = reinterpret_cast<SNode*>(m_space);
    SNode* psn = dynamic_cast<SNode*>(pn);

    for(int i = 0; i < N; i++)
    {
        if(pn == space + i)
        {
            m_used[i] = 0; // 循环每块内存，标记为未使用
            psn->~SNode(); // 析构节点
            break; // 找到了对应需要删除的内存块，没必要继续循环了
        }
    }
}
```

在`if`中额外添加一个`break`。

6. 构造函数和析构函数中不发生多态，因此`LinkList::~LinkList()`中只会调用自身的`clear()`函数，而`clear()`中又继续调用自身的`destroy()`。如果`StaticLinkList`不定义自己的析构函数，在该对象被析构的时候，先调用默认析构函数，然后调用父类的析构函数，最终调用父类版本的`destroy()`，在其中用`delete`的方式释放栈内存，导致程序不稳定。因此需要添加子类的析构函数：

```cpp
~StaticLinkList()
{
    this->clear(); // 构造函数和析构函数中不发生多态，只会调用自身版本的虚函数，这里调用继承过来的clear()，并在clear()中调用自身的destroy()
}
```

在模版类中，调用从父类继承过来的函数要用到`this`，但本质还是调用自身的成员函数。

**注意**：区别`this->clear()`和`LinkList::clear()`，前者是调用自身的虚函数，后者是调用父类的虚函数。

7. 定义二维数组对象

```cpp
int main()
{
    DynamicArray< DynamicArray<int> > d;

    d.resize(3);

    for(int i = 0; i < d.length(); i++)
    {
        d[i].resize(3);
    }

    for(int i = 0; i < d.length(); i++)
    {
        for(int j = 0; j < d[i].length(); j++)
        {
            d[i][j] = i * j;
        }
    }

    for(int i = 0; i < d.length(); i++)
    {
        for(int j = 0; j < d[i].length(); j++)
        {
            cout << d[i][j] << " ";
        }

        cout << endl;
    }

    return 0;
}
```