# 智能指针的析构函数

先从一个简单的例子来说明问题，假设有如下代码：

```cpp
class Person{
public:
    Person(int param){
        this->mParam = param;
    }
    void PrintPerson(){
        cout << "Param:" << mParam << endl;
    }
private:
    int mParam;
};

void test01(){
    Person* person = new Person(100);
    // 如果忘记释放，那么就会造成内存泄漏
}
```

对于一个堆区对象，总是需要自己去释放内存，如果忘记容易内存泄漏，因此可以考虑定义这样一个智能指针类：

```cpp
class SmartPointer{
public:
    SmartPointer(Person* person){
        this->pPerson = person;
    }
    ~SmartPointer(){
        if (pPerson != NULL){
            delete pPerson;
        }
    }
public:
    Person* pPerson;
};

void test01(){
    SmartPointer pointer(new Person(100));
}
```

这个智能指针类`SmartPointer`里维护一个`Person`类指针，当`SmartPointer`离开`test01`作用域，就会调用析构函数`~SmartPointer`，并释放`Person`的内存。

# 智能指针的成员访问运算符重载

但是这样看起来还不像指针，既然是指针，就得有`->`和`*`操作符，因此需要重载这两个操作符：

```cpp
class SmartPointer{
public:
    SmartPointer(Person* person){
        this->pPerson = person;
    }
    //重载指针的->、*操作符
    Person* operator->(){
        return pPerson;
    }
    Person& operator*(){
        return *pPerson;
    }
    ~SmartPointer(){
        if (pPerson != NULL){
            delete pPerson;
        }
    }
public:
    Person* pPerson;
};

void test01(){
    SmartPointer pointer(new Person(100));
    pointer->PrintPerson();
}
```

可以看到，当调用`->`运算符时，`SmartPointer`返回自身维护的`Person`指针。

**注意**：实际上编译器在这里做了一个优化操作，`pointer->`返回`pPerson`，最后的表达式变为`pPerson PrintPerson()`，实际上编译器把这一段代码变成了`pointer->->PrintPerson()`，最后返回的表达式才是`pPerson->PrintPerson()`

类似的`*`操作符返回`pPerson`指向对象的内存。

# 改进指针指针

这个指针不具备通用性，因此可以考虑用泛型的方式设计，且要求内存与指针是一对一关系，即一块内存只能被一个指针指向：

`SmartPointer.h`
```cpp
template <typename T>
class SmartPointer
{
private:
    T* m_ptr = nullptr;

public:
    SmartPointer(T* ptr) // 允许类型转换构造函数，如果定义为explicit则会禁用
    {
        m_ptr = ptr;
    }

    SmartPointer(const SmartPointer<T>& rhs)
    {
        m_ptr = rhs.m_ptr;

        const_cast<SmartPointer<T>&>(rhs).m_ptr = nullptr; // 容易忘记。如果原指针不置空，就有两个指针指向同一块内存，释放内存后，另一个指针可能还会继续操作这块内存
    }

    SmartPointer& operator=(const SmartPointer<T>& rhs)
    {
        if(this != &rhs)
        {
            delete m_ptr; // 容易忘记。要把原来的空间释放掉，再接收新的空间，否则会发生内存泄漏

            m_ptr = rhs.m_ptr;
            const_cast<SmartPointer<T>&>(rhs).m_ptr = nullptr;
        }

        return *this;
    }

    T* operator->() // 这里应该返回T*也就是维护的指针类型，而不是SmartPointer*
    {
        return m_ptr;
    }

    T& operator*()
    {
        return *m_ptr;
    }

    ~SmartPointer()
    {
        if(m_ptr != nullptr)
        {
            delete m_ptr;
        }
    }
};
```

`main.cpp`
```cpp
class Test
{
public:
    Test(int i):m_i(i)
    {
        cout << "Test" << endl;
    }

    int getNum()
    {
        return m_i;
    }

    ~Test()
    {
        cout << "~Test" << endl;
    }

private:
    int m_i;
};

int main()
{
    SmartPointer<Test> TestPtr = new Test(10); // = 右边是Test*类型，= 左边是TestPtr类型，而TestPtr的构造函数只有一个形参，可以隐式转换
                                             // ref. <<C++ primer>> -- 7.5.4隐式的类类型转换 P264

    cout << TestPtr->getNum() << endl;
    return 0;
}
```