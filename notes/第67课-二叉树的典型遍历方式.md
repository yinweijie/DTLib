1. 定义`traversal`函数，实现三种遍历方式，即先序遍历、中序遍历和后序遍历

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200624230526.png)

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200624230550.png)

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200624230604.png)

递归实现代码：

```cpp
private:
    void preOrderTraversal(BTreeNode<T>* node, LinkQueue<BTreeNode<T>*>& queue)
    {
        if(node != nullptr)
        {
            queue.add(node);
            preOrderTraversal(node->left, queue);
            preOrderTraversal(node->right, queue);
        }
    }

    void inOrderTraversal(BTreeNode<T>* node, LinkQueue<BTreeNode<T>*>& queue)
    {
        if(node != nullptr)
        {
            inOrderTraversal(node->left, queue);
            queue.add(node);
            inOrderTraversal(node->right, queue);
        }
    }

    void postOrderTraversal(BTreeNode<T>* node, LinkQueue<BTreeNode<T>*>& queue)
    {
        if(node != nullptr)
        {
            postOrderTraversal(node->left, queue);
            postOrderTraversal(node->right, queue);
            queue.add(node);
        }
    }
```

遍历函数：

```cpp
public:
    SharedPointer<Array<T>> traversal(BTTraversal order)
    {
        DynamicArray<T>* ret = nullptr;
        LinkQueue<BTreeNode<T>*> queue;

        switch(order)
        {
        case PreOder:
            preOrderTraversal(root(), queue);
            break;
        case InOrder:
            inOrderTraversal(root(), queue);
            break;
        case PostOrder:
            postOrderTraversal(root(), queue);
            break;
        default:
            THROW_EXCEPTION(InvalidParameterException, "Parameter order is invalid ...");
            break;
        }

        ret = new DynamicArray<T>(queue.length());

        if(ret != nullptr)
        {
            for(int i = 0; i < ret->length(); i++)
            {
    //            (*ret)[i] = queue.front()->value;
                ret->set(i, queue.front()->value);
                queue.remove();
            }
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException, "No memory to create return array ...");
        }

        return ret;
    }
```

递归函数会将节点指针`BTreeNode*`存入队列中，遍历函数中将队列中的元素逐一弹出，并将其值保存在一个数组`DynamicArray`中，最终返回智能指针，该指针指向这个动态数组。

这么做的好处是，在调用处，不用自己去释放返回这个动态数组对象。