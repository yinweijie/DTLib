1. 创建数组类`DynamicArray`：

接口为：
```cpp
template <typename T>
class DynamicArray : public Array<T>
{
protected:
    int m_length;
public:
    DynamicArray(int length);
    DynamicArray(const DynamicArray<T>& rhs);

    DynamicArray<T>& operator=(const DynamicArray<T>& rhs);

    int length() const;
    void resize(int length);

    ~DynamicArray();
};
```

定义为：
```cpp
template <typename T>
class DynamicArray : public Array<T>
{
protected:
    int m_length;

public:
    DynamicArray(int length)
    {
        T* arr = new T[length];

        if(arr != nullptr)
        {
            this->m_array = arr;
            m_length = length;
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException, "No enough memory to create DynamicArray ...");
        }
    }

    DynamicArray(const DynamicArray<T>& rhs)
    {
        T* arr = new T[rhs.m_length];

        if(arr != nullptr)
        {
            this->m_array = arr;
            m_length = rhs.m_length;

            for(int i = 0; i < m_length; i++)
            {
                this->m_array[i] = rhs.m_array[i];
            }
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException, "No enough memory to create DynamicArray ...");
        }
    }

    DynamicArray<T>& operator=(const DynamicArray<T>& rhs)
    {
        if(this != &rhs)
        {
            T* arr = new T[rhs.m_length]; // 既然是拷贝，就应该把对方一模一样搬过来，所以需要重新分配内存，而不是只把对方内容拷贝到现有内存中，因为现有m_length可能不够大

            if(arr != nullptr)
            {
                for(int i = 0; i < m_length; i++)
                {
                    arr[i] = rhs.m_array[i];
                }

                T* tmp = this->m_array;

                m_length = rhs.m_length;
                this->m_array = arr;

                delete[] tmp;
            }
            else
            {
                THROW_EXCEPTION(NoEnoughMemoryException, "No enough memory to copy DynamicArray ...");
            }
        }

        return *this;
    }

    int length() const
    {
        return m_length;
    }

    void resize(int length)
    {
        if(m_length == length) return;

        T* arr = new T[length];

        if(arr != nullptr)
        {
            int size = length < m_length ? length : m_length; // 拷贝个数以较小的长度的那个为准

            for(int i = 0; i < size; i++)
            {
                arr[i] = this->m_array[i];
            }

            T* tmp = this->m_array;

            m_length = length;
            this->m_array = arr;

            delete[] tmp;
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException, "No enough memory to resize ...");
        }
    }

    ~DynamicArray()
    {
        delete[] this->m_array;
    }
};
```

2. 代码重构，定义三个函数：

`init`：对象构造时的初始化操作；即`void init(T* arr, int length)`将传入的`arr`和`length`用来初始化`m_arr`和`m_length`

`copy`：在对空间申请内存，并执行拷贝操作；即`T* copy(T* arr, int len, int newLen)`将`arr[len]`的内容拷贝到新创建的数组`ret[newLen]`中，并返回

`update`：将指定的对空间作为内部存储数组使用；即`void update(T* arr, int length)`将`arr[length]`挂载到`m_arr`并删除原来指向的内存，并更新`m_length`

重构后的代码：
```cpp
template <typename T>
class DynamicArray : public Array<T>
{
protected:
    int m_length;

    T* copy(T* arr, int len, int newLen) // O(min(len, newLen)) ==> O(n)
    {
        T* ret = new T[newLen];

        if(ret != nullptr)
        {
            int size = len < newLen ? len : newLen;

            for(int i = 0; i < size; i++)
            {
                ret[i] = arr[i];
            }
        }

        return ret;
    }

    void update(T* arr, int length) // O(1)
    {
        if(arr != nullptr)
        {
            T* tmp = this->m_array;

            this->m_array = arr;
            m_length = length;

            delete[] tmp;
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException, "No enough memory to create DynamicArray ...");
        }
    }

    void init(T* arr, int length) // O(1)
    {
        if(arr != nullptr)
        {
            this->m_array = arr;
            m_length = length;
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException, "No enough memory to create DynamicArray ...");
        }
    }

public:
    DynamicArray(int length) // O(1)
    {
        init(new T[length], length);
    }

    DynamicArray(const DynamicArray<T>& rhs) // O(n)
    {
        init(copy(rhs.m_array, rhs.m_length, rhs.m_length), rhs.m_length);
    }

    DynamicArray<T>& operator=(const DynamicArray<T>& rhs) // O(n)
    {
        if(this != &rhs)
        {
            update(copy(rhs.m_array, rhs.m_length, rhs.m_length), rhs.m_length);
        }

        return *this;
    }

    int length() const // O(1)
    {
        return m_length;
    }

    void resize(int length) // O(n)
    {
        if(m_length == length) return;

        update(copy(this->m_array, m_length, length), length);
    }

    ~DynamicArray() // O(1)
    {
        delete[] this->m_array;
    }
};
```