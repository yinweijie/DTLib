1. 单向链表的反转

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200604214107.png)

代码实现：
```cpp
Node* reverse_list(Node* head)
{
    if((head == nullptr) || (head->next == nullptr))
    {
        return head; // 如果链表为空或者只有一个节点时，直接返回链表头节点
    }

    Node* guard = head->next;
    Node* ret = reverse_list(head->next); // 翻转当前节点后面的所有节点
    guard->next = head;
    head->next = nullptr;

    return ret;
}
```

2. 单向排序链表的合并

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200604214503.png)

代码实现：
```cpp
Node* merge(Node* list1, Node* list2)
{
    if(list1 == nullptr)
    {
        return list2;
    }
    if(list2 == nullptr)
    {
        return list1;
    }

    if(list1->value < list2->value)
    {
//        list1->next = merge(list1->next, list2);
//        return list1;
        return (list1->next = merge(list1->next, list2), list1); // 逗号表达式：对于(a, b)，执行语句a，然后返回b
    }
    if(list2->value >= list1->value)
    {
//        list2->next = merge(list1, list2->next);
//        return list2;
        return (list2->next = merge(list1, list2->next), list2);
    }

    return nullptr;
}
```

3. 汉诺塔问题

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200604214552.png)

代码实现：
```cpp
void HanoiTower(int n, char a, char b, char c) // 借助b，将n个元素从a移动到c
{
    if(n == 1)
    {
        cout << a << "-->" << c << endl;
    }
    else
    {
        HanoiTower(n-1, a, c, b); // 先将n-1个元素，借助c，从a移动到b
        HanoiTower(1, a, b, c); // 然后将最后一个元素，借助b，从a移动到c
        HanoiTower(n-1, b, a, c); // 最后将n-1个元素，借助a，从b移动到c
    }
}
```

4. 全排列问题

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200604214610.png)

代码实现：
```cpp
void permutation(char* s, char* e)
{
    if(*s == '\0')
    {
        cout << e << endl; // e永远记录的是首地址，打印整个字符串
    }
    else
    {
        int len = strlen(s);

        for(int i = 0; i < len; i++)
        {
            if((i == 0) || (s[0] != s[i]))
            {
                swap(s[0], s[i]); // 分别让a, b, c在首位
                permutation(s+1, e); // 全排列后面的字符并输出
                swap(s[0], s[i]);
            }
        }
    }
}
```