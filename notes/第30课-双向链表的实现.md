1. 实现双向链表`DualLinkList`，继承自`List`，其类结构关系图为：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200523173948.png)

结构图为：
![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200523174029.png)

类声接口为：

```cpp
template <typename T>
class DualLinkList : public List<T>
{
protected:
    struct Node : public Object
    {
        T value;
        Node* next;
        Node* pre;
    };

    mutable struct : public Object
    {
        char reserved[sizeof(T)];
        Node* next;
        Node* pre;
    } m_header;

    ...
};
```

可以直接复用`LinkList`的代码，需要做出的修改有：

```cpp
DualLinkList()
{
    m_header.next = nullptr;
    m_header.pre = nullptr; // 新增成员初始化
    m_length = 0;
    m_step = 1;
    m_current = nullptr;
}
```

```cpp
bool insert(int i, const T& e) override // O(n)
{
    bool ret = (0 <= i) && (i <= m_length);

    if(ret)
    {
        Node* node = create();

        if(node != nullptr)
        {
            Node* current = position(i);
            Node* next = current->next; // 需要额外记录next节点的位置

            node->value = e;

            node->next = next;
            current->next = node;

            if(current != reinterpret_cast<Node*>(&m_header)) // 第0个元素的pre是不需要指向头结点的
            {
                node->pre = current;
            }
            else
            {
                node->pre = nullptr;
            }

            if(next != nullptr) // 插入位置可以为m_lenght，此时没有next节点，也就不需要更新next节点的pre
            {
                next->pre = node;
            }

            m_length++;
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException, "No enough memory to insert element ...");
        }
    }

    return  ret;
}
```

```cpp
bool remove(int i) override // O(n)
{
    bool ret = (0 <= i) && (i < m_length);

    if(ret)
    {
        Node* current = position(i);
        Node* toDel = current->next;
        Node* next = toDel->next; // 需要额外记录next节点的位置

        if(m_current == toDel)
        {
            m_current = next;
        }

        current->next = toDel->next;

        if(next != nullptr) // toDel可能是最后一个元素，此时next为空
        {
            next->pre = toDel->pre; // current有可能是头节点，如果直接next->pre = current，就变成指向头节点了
        }

        m_length--; 

        destroy(toDel);
    }

    return ret;
}
```

```cpp
void clear() override // 代码优化后更简洁
{
    while(m_length > 0)
    {
        remove(0);
    }
}
```

增加一个成员函数：
```cpp
virtual bool pre()
{
    int i = 0;

    while((i < m_step) && !end())
    {
        m_current = m_current->pre;
        i++;
    }

    return (i == m_step);
}
```

修改析构函数的名字：
```cpp
~DualLinkList() // O(n)
{
    clear(); // 构造函数和析构函数中不发生多态，只会调用自身版本的虚函数
}
```