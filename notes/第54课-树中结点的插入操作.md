往树中插入节点时，需要指定两个量，一个是插入节点中包含的数据，另一个是插入的位置，而位置信息包含在插入节点的`parent`成员中，在做插入操作时，会先寻找`parent`的位置，然后做插入操作。

1. `insert`操作的实现

实现如下两个版本的插入操作，上面的版本直接将构造好的节点（包含`value`和`parent`信息）插入到合适位置，下面的版本会先根据`value`和`parent`信息创建节点，然后调用上面的版本插入节点。
```cpp
bool insert(TreeNode<T>* node) override
{
    bool ret = true;

    if(node != nullptr)
    {
        if(this->m_root == nullptr) // 当还未创建根节点时，先创建根节点
        {
            this->m_root = node;
            node->parent = nullptr;
        }
        else
        {
            GTreeNode<T>* np = find(node->parent); // 根据待插入节点的parent信息，寻找插入位置

            if(np != nullptr)
            {
                GTreeNode<T>* n = dynamic_cast<GTreeNode<T>*>(node);

                if(np->child.find(n) < 0)
                {
                    np->child.insert(node); // 当找到的parent节点没有待插入的节点时，往其child链表中插入该节点
                }
            }
            else
            {
                THROW_EXCEPTION(InvalidParameterException, "Invalid parent node ...");
            }
        }
    }
    else
    {
        THROW_EXCEPTION(InvalidParameterException, "Invalid tree node ...");
    }

    return ret;
}

bool insert(const T& value, TreeNode<T>* parent) override
{
    bool ret = true;

    GTreeNode<T>* node = new GTreeNode<T>();

    if(node != nullptr)
    {
        node->value = value;
        node->parent = parent;

        insert(node); // 根据指定的value和parent来创建节点，并传入上面那个insert函数
    }
    else
    {
        THROW_EXCEPTION(NoEnoughMemoryException, "No memory to create node ...");
    }

    return ret;
}
```

2. 使用`insert`函数

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200613163538.png)

下面构造出上面的树结构（不包含`N`）：

```cpp
int main()
{
    GTree<char> tree;
    GTreeNode<char>* node;

    tree.insert('A', nullptr); // 插入第一个节点，没有父节点

    node = tree.find('A'); // 找到父节点

    tree.insert('B', node); // 在父节点的child链表中插入节点
    tree.insert('C', node);
    tree.insert('D', node);

    node = tree.find('B');

    tree.insert('E', node);
    tree.insert('F', node);

    node = tree.find('E');

    tree.insert('K', node);
    tree.insert('L', node);

    node = tree.find('C');

    tree.insert('G', node);

    node = tree.find('D');

    tree.insert('H', node);
    tree.insert('I', node);
    tree.insert('J', node);

    node = tree.find('H');

    tree.insert('M', node);

    const char* s = "KLFGMIJ";

    for(int i = 0; i < 7; i++)
    {
        TreeNode<char>* node = tree.find(s[i]); // 找到叶子节点
        while(node != nullptr) // 以叶子节点为起点，用链表的方式往根节点前进
        {
            cout << node->value << " ";
            node = node->parent;
        }
        cout << endl;
    }

    return 0;
}
```

由于每个节点都有`parent`成员，因此非常容易借助这个指针往根节点方向前进，这样就可以从每个叶子节点为起始，沿每条树的分支输出所有节点，输出结果为：

```
K E B A
L E B A
F B A
G C A
M H D A
I D A
J D A
```