1. 用链表来实现队列数据结构，定义`LinkQueue`，继承自`Queue`，且内部包含一个`LinkList`成员。数组方式实现的队列，在创建对象的时候，会调用`N`次泛型类型`T`的构造函数和析构函数。

2. 由于链表没有长度限制，因此不需要泛型参数`N`，也没有`capacity`这个函数。但是这种实现有缺陷，那就是`add`操作是在链表尾部插入元素，时间复杂度太高。其类实现为：

```cpp
template <typename T>
class LinkQueue : public Queue<T>
{
protected:
    LinkList<T> m_list;
public:
    LinkQueue()
    {

    }

    void add(const T& e) // O(n)
    {
        m_list.insert(e);
    }

    void remove() // O(1)
    {
        if(m_list.length() > 0)
        {
            m_list.remove(0);
        }
        else
        {
            THROW_EXCEPTION(InvalidParameterException, "No element in current queue ...");
        }
    }

    T front() const // O(1)
    {
        if(m_list.length() > 0)
        {
            return m_list.get(0);
        }
        else
        {
            THROW_EXCEPTION(InvalidParameterException, "No element in current queue ...");
        }
    }

    void clear() // O(1)
    {
        m_list.clear();
    }

    int length() const // O(1)
    {
        return m_list.length();
    }
};
```

3. 为了解决第2个问题，可以借助Linux内核中的链表来实现，该链表结构示意图为：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200526204327.png)

可以看到，头节点既能指向头部，也能指向尾部，这样一来，`add`操作的时间复杂度就变为1了。