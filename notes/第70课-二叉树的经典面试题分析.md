#### 1. 删除单度节点，删除该节点后，其唯一子节点代替它的位置

举例：
![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200630141349.png)

删除过程为：
- 1被删除，3代替1的位置
- 3被删除，6代替3的位置
- 4被删除，7代替4的位置
- 5被删除，8代替5的位置

#### 2. 节点包含父节点的情况

**注**：当面试的时候，需要和面试官沟通，节点是否包含指向父节点的指针

用上面的情况举例，如果要删除1，则将0的`left`指针指向3，将3的`parent`指针指向0，并删除1节点

算法描述为：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200630141200.png)

代码：

```cpp
template <typename T>
BTreeNode<T>* delOdd1(BTreeNode<T>* node)
{
    BTreeNode<T>* ret = nullptr;

    if(node != nullptr)
    {
        if( ((node->left != nullptr) && (node->right == nullptr)) ||
            ((node->left == nullptr) && (node->right != nullptr)) )
        {
            BTreeNode<T>* parent = dynamic_cast<BTreeNode<T>*>(node->parent);
            BTreeNode<T>* node_child = node->left != nullptr ? node->left : node->right; // 确定当前节点拥有的孩子是左孩子还是右孩子

            if(parent != nullptr)
            {
                BTreeNode<T>*& parent_child = parent->left == node ? parent->left : parent->right;

                parent_child = node_child;

//                上面的代码是下面注释代码的简化版本
//                if(parent->left == node) // 确定当前节点是父节点的左孩子还是右孩子
//                {
//                    parent->left = node_child; // 让父节点指向当前节点的孩子节点
//                }
//                else if(parent->right == node)
//                {
//                    parent->right = node_child;
//                }

                node_child->parent = parent; // 让当前节点的子节点指向父节点
            }
            else
            {
                node_child->parent = nullptr;
            }

            if(node->flag())
            {
                delete node;
            }

            ret = delOdd1(node_child);
        }
        else
        {
            delOdd1(node->left);
            delOdd1(node->right);

            ret = node; // 度为2的节点，最后一定会返回当前节点
        }
    }

    return ret;
}
```

#### 3. 节点不包含父节点的情况

```cpp
template <typename T>
void delOdd2(BTreeNode<T>*& node)
{
    if(node != nullptr)
    {
        if( ((node->left != nullptr) && (node->right == nullptr)) ||
            ((node->left == nullptr) && (node->right != nullptr)) )
        {
            BTreeNode<T>* toDel = node;
            node = node->left != nullptr ? node->left : node->right;
            // 由于node是引用，因此当传入的是left或者right节点时，直接修改node为其孩子节点，相当于让node的父节点指向node的孩子

            if(toDel->flag())
            {
                delete toDel;
            }

            delOdd2(node);
        }
        else
        {
            delOdd2(node->left);
            delOdd2(node->right);
        }
    }
}
```

#### 4. 线索化二叉树，不借助其他数据结构

具体操作就是在遍历的过程中，进行指针的连接：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200630203444.png)

代码方法一：

```cpp
template <typename T>
void inOrderThread(BTreeNode<T>* node, BTreeNode<T>*& pre)
{
    if(node != nullptr)
    {
        inOrderThread(node->left, pre); // 先中序遍历左子树，并且pre会被修改为遍历后的最后那个元素

        node->left = pre; // 将当前节点指向pre，也即左子树线索化后的最后一个元素

        if(pre != nullptr)
        {
            pre->right = node; // 同时pre也需要指向当前节点
        }

        pre = node; // 更新pre，始终保证pre跟随当前节点，这样保证中序遍历完成后，pre保存遍历的最后一个元素

        inOrderThread(node->right, pre); // 中序遍历右子树，该过程可以借鉴中序遍历打印去理解
    }
}

template <typename T>
BTreeNode<T>* inOrderThread1(BTreeNode<T>* node)
{
    BTreeNode<T>* pre = nullptr;

    inOrderThread(node, pre);

    while(node != nullptr && node->left != nullptr)
    {
        node = node->left;
    }

    return node;
}
```

方法二：

```cpp
template <typename T>
void inOrderThread(BTreeNode<T>* node, BTreeNode<T>*& head, BTreeNode<T>*& tail)
{
    if(node != nullptr)
    {
        BTreeNode<T>* h = nullptr;
        BTreeNode<T>* t = nullptr;

        inOrderThread(node->left, h, t);

        node->left = t;

        if(t != nullptr)
        {
            t->right = node;
        }

        head = h != nullptr ? h : node;
        cout << head << " " << h << " " << node << " " << node->value << endl;

        h = nullptr;
        t = nullptr;

        inOrderThread(node->right, h, t);

        node->right = h;

        if(h != nullptr)
        {
            h->left = node;
        }

        tail = t != nullptr ? t : node;
    }
}

template <typename T>
BTreeNode<T>* inOrderThread2(BTreeNode<T>* node)
{
    BTreeNode<T>* head = nullptr;
    BTreeNode<T>* tail = nullptr;

    inOrderThread(node, head, tail);

    return head;
}
```