1. 删除节点

删除节点的示意图如下：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200615171553.png)

对于删除的节点，需要将整个子树从这个树中移除，然后返回这个子树，并用指向树类型的智能指针去接管，至于后序是直接删除整个树还是继续使用这个树，就交给类用户决定。

代码实现为：

```cpp
private:

...

void remove(GTreeNode<T>* node, GTree<T>*& ret)
{
    ret = new GTree<T>();

    if(ret != nullptr)
    {
        if(root() == node) // 如果删除的是根节点，那么调用remove以后，这个树对象的m_root就变为空了
        {
            this->m_root = nullptr;
        }
        else // 如果删除的不是根节点，则需要根据节点去定位该节点所在的child链表，将该节点从链表中移除（但是并不释放内存空间）
        {
            LinkList<GTreeNode<T>*>& child = dynamic_cast<GTreeNode<T>*>(find(node)->parent)->child;

            child.remove(child.find(node)); // 移除节点有两步：1. 从child链表中删除；2. 将parent指针置空

            node->parent = nullptr;
        }

        ret->m_root = node; // 将该节点设置为新创建的树的根节点
    }
    else
    {
        THROW_EXCEPTION(NoEnoughMemoryException, "No memory to create new tree ...");
    }
}

public:

...

// 有两个版本，一个是基于值来删除，一个是基于节点来删除
SharedPointer<Tree<T>> remove(const T& value) override
{
    GTree<T>* ret = nullptr;
    GTreeNode<T>* node = find(value); // 首先找到这个点在树中的位置

    if(node != nullptr)
    {
        remove(node, ret); // 找到了才进行删除
    }
    else
    {
        THROW_EXCEPTION(InvalidParameterException, "Cannot find the node via value parameter ...");
    }

    return ret;
}

SharedPointer<Tree<T>> remove(TreeNode<T>* node) override
{
    GTree<T>* ret = nullptr;

    node = find(node); // 看看node是否在树中

    if(node != nullptr)
    {
        remove(dynamic_cast<GTreeNode<T>*>(node), ret);
    }
    else
    {
        THROW_EXCEPTION(InvalidParameterException, "Cannot find the node via node parameter ...");
    }

    return ret;
}
```

2. 移除测试

```cpp
int main()
{
    GTree<char> tree;
    GTreeNode<char>* node;

    GTreeNode<char> root;
    root.value = 'A';
    root.parent = nullptr;

    tree.insert(&root);

    node = tree.find('A');

    tree.insert('B', node);
    tree.insert('C', node);
    tree.insert('D', node);

    node = tree.find('B');

    tree.insert('E', node);
    tree.insert('F', node);

    node = tree.find('E');

    tree.insert('K', node);
    tree.insert('L', node);

    node = tree.find('C');

    tree.insert('G', node);

    node = tree.find('D');

    tree.insert('H', node);
    tree.insert('I', node);
    tree.insert('J', node);

    node = tree.find('H');

    tree.insert('M', node);

//    tree.remove('D');
//    tree.remove(tree.find('D'));
    SharedPointer<Tree<char>> p = tree.remove('D'); // p如果看作指针，那么它就是指向GTree<char>类型的Tree<char>指针

    const char* s = "KLFGMIJ";

    for(int i = 0; i < 7; i++)
    {
//        TreeNode<char>* node = tree.find(s[i]);
        TreeNode<char>* node = p->find(s[i]); // 在这里，调用虚函数会发生多态

        while(node != nullptr)
        {
            cout << node->value << " ";
            node = node->parent;
        }
        cout << endl;
    }

    return 0;
}
```

移除节点有两种场景：1. 直接调用`remove`函数；2. 用智能指针`SharedPointer<Tree<char>>`去指向返回的子树。

对于第一种情况，由于返回的是智能指针临时变量，会在该条语句结束后，智能指针被析构，并调用`Tree`的析构函数，释放整个树的内存

对于第二种情况，当返回的子树被接收后，可以继续进行操作。