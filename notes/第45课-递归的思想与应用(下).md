1. 函数调用过程

- 程序运行后有一个特殊的内存区供函数调用使用
    - 用于保存函数中的实参，局部变量，临时变量，等
    - 从起始地址开始往一个方向增长(如:高地址→低地址)
    - 有一个专用“指针”标识当前已使用内存的“顶部”

函数栈示意图：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200606183502.png)


2. 逆序打印链表中偶数节点

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200606183638.png)

代码实现为：

```cpp
void r_print_even(Node* list)
{
    if(list != nullptr)
    {
        r_print_even(list->next); // 会将本次函数调用连同实参值（指针）压入栈中，然后进行下一次调用
        if(list->value % 2 == 0)
        {
            cout << list->value << endl;
        }
    }
}
```

可以看到，当递归进行到最后一层时，函数返回，函数栈开始逐一弹出，并打印偶数节点。

3. 回溯算法与八皇后问题

在一个8×8的国际象棋棋盘上，有8个皇后，每个皇后占一格；要求皇后间不会出现相互"攻击"的现象（不能有两个皇后处在**同一行**、**同一列**或**同一对角线**上）。

代码实现为：

```cpp
template <int SIZE>
class QueenSolution : public Object
{
protected:
    enum {N = SIZE + 2}; // 将棋盘周围围一圈，棋盘大小为SIZE * SIZE

    struct Pos : public Object // 有两个作用，记录位置和当作矢量方向
    {
        Pos(int px = 0, int py = 0) : x(px), y(py) { }
        int x;
        int y;
    };

    int m_chessboard[N][N]; // 棋盘标记：0为空位置，1位放置棋子，2为边界
    Pos m_direction[3]; // 记录三个方向，左下，下，右下
    LinkList<Pos> m_solution; // 将放棋子的位置记录到链表中
    int m_count; // 解的个数

    void init()
    {
        m_count = 0;

        for(int i = 0; i < N; i += (N-1)) // 将边界标记为2
        {
            for(int j = 0; j < N; j++)
            {
                m_chessboard[i][j] = 2;
                m_chessboard[j][i] = 2;
            }
        }

        for(int i = 1; i <= SIZE; i++) // 将棋盘初始化为0
        {
            for(int j = 1; j <= SIZE; j++)
            {
                m_chessboard[i][j] = 0;
            }
        }

        // 三个方向，用来计算当前位置是否可以放棋子
        m_direction[0].x = -1;
        m_direction[0].y = -1;
        m_direction[1].x =  0;
        m_direction[1].y = -1;
        m_direction[2].x =  1;
        m_direction[2].y = -1;
    }

    void print()
    {
        // 依次打印放棋子的坐标
        for(m_solution.move(0); !m_solution.end(); m_solution.next())
        {
            cout << "(" << m_solution.current().x << ", " << m_solution.current().y << ") ";
        }

        cout << endl;

        // 将棋盘和棋子位置显示出来
        for(int i = 0; i < N; i++)
        {
            for(int j = 0; j < N; j++)
            {
                switch (m_chessboard[i][j])
                {
                    case 0 : cout << " "; break;
                    case 1 : cout << "#"; break;
                    case 2 : cout << "*"; break;
                }
            }

            cout << endl;
        }

        cout << endl;
    }

    bool check(int x, int y, int d)
    {
        bool flag = true;

        do // 判断位置(x, y)在d方向是否有棋子
        {
            x += m_direction[d].x;
            y += m_direction[d].y;

            flag = flag && (m_chessboard[x][y] == 0); // 如果没有棋子，就继续往这个方向寻找
        }
        while(flag);

        return (m_chessboard[x][y] == 2); // 如果到达边界了，说明这个方向没有棋子
    }

    void run(int j) // 从第j行开始，依次寻找此行的位置i可否放置棋子
    {
        if(j <= SIZE)
        {
            for(int i = 1; i <= SIZE; i++)
            {
                if(check(i, j, 0) && check(i, j, 1) && check(i, j, 2)) // 三个方向都没有棋子
                {
                    m_chessboard[i][j] = 1; // 这个位置可以放置棋子
                    m_solution.insert(Pos(i, j));

                    run(j + 1); // 继续寻找下一行

                    // 上面的函数返回有两种原因：1. j > SIZE，此时打印出了解；2. for循环都结束了，也没能找到合法的位置
                    // 这两种情况结束后，下一步都应该做同样的操作，也就是清零此时的位置，看看i到下一个位置后，解有哪些可能性
                    m_chessboard[i][j] = 0;
                    
                    m_solution.remove(m_solution.length() - 1);
                }
            }
        }
        else
        {
            m_count++; // 此时j > SIZE，说明已经到头了，记录一个解
            print(); // 打印这个解
        }
    }

public:
    QueenSolution()
    {
        init();
    }

    void run()
    {
        run(1);

        cout << "Total: " << m_count << endl;
    }
};
```