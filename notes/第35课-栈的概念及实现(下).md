1. `StaticStack`由于其内部有成员`T m_space[N]`，因此即使创建一个空的`StaticStack`，也会调用`N`次`T`对象的构造函数和析构函数。

2. 定义`LinkStack`，继承自`Stack`，且内部用`LinkList`去维护栈对象，只对头节点进行操作，`push`操作就是在头节点插入对象，`pop`操作就是在头节点删除对象。

其类结构图为：
![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200525161118.png)

类定义为：
```cpp
template <typename T>
class LinkStack : public Stack<T>
{
protected:
    LinkList<T> m_list;
public:
    void push(const T& e) override // O(1)
    {
        m_list.insert(0, e);
    }

    void pop() override // O(1)
    {
        if(m_list.length() > 0)
        {
            m_list.remove(0);
        }
        else
        {
            THROW_EXCEPTION(InvalidParameterException, "No element in current stack ...");
        }
    }

    T top() const override // O(1)
    {
        if(m_list.length() > 0)
        {
            return m_list.get(0);
        }
        else
        {
            THROW_EXCEPTION(InvalidParameterException, "No element in current stack ...");
        }
    }
    void clear() override // O(n)
    {
        m_list.clear();
    }

    int size() const override // O(1)
    {
        return  m_list.length();
    }
};
```

3. 利用栈来实现符号匹配检查。

算法思路

- 从第一个字符开始扫描
当遇见普通字符时忽略
当遇见左符号时压入栈中
当遇见右符号时弹出栈顶符号，并进行匹配

- 结束
成功：所有字符扫描完毕，且栈为空
失败：匹配失败或所有字符扫描完毕但栈非空

**注意**：`top()`操作必须保证栈内有元素，因此涉及到`top()`调用的地方，要看看如果栈内没有元素会是什么情况。

代码：
```cpp
bool is_left(char c)
{
    return (c == '(') || (c == '{') || (c == '[') || (c == '<');
}

bool is_right(char c)
{
    return (c == ')') || (c == '}') || (c == ']') || (c == '>');
}

bool is_quote(char c)
{
    return (c == '\'') || (c == '\"');
}

bool is_match(char l, char r)
{
    return ( (l == '(') && (r == ')') ) ||
           ( (l == '{') && (r == '}') ) ||
           ( (l == '[') && (r == ']') ) ||
           ( (l == '<') && (r == '>') ) ||
           ( (l == '\'') && (r == '\'') ) ||
           ( (l == '\"') && (r == '\"') );
}

bool scan(const char* code)
{
    LinkStack<char> stack;
    int i = 0;
    bool ret = true;

    code = (code == nullptr) ? "" : code;

    while(ret && code[i] != '\0')
    {
        if(is_left(code[i])) // 遇见左符号时压入栈中
        {
            stack.push(code[i]);
        }
        else if(is_right(code[i])) // 遇见右符号时弹出栈顶符号，并进行匹配
        {
            if(stack.size() > 0 && is_match(stack.top(), code[i])) // 有右符号，则栈内必须有左符号，如果没有则不匹配。如果栈为空，top()操作会抛异常
            {
                stack.pop();
            }
            else
            {
                ret = false;
            }
        }
        else if(is_quote(code[i]))
        {
            if(stack.size() == 0 || !is_match(stack.top(), code[i])) // 引号本身没有左右之分，必须借助栈顶是否有匹配的引号，或者是否为第一个元素，来判断其左右
            {
                stack.push(code[i]);
            }
            else if(is_match(stack.top(), code[i]))
            {
                stack.pop();
            }
        }

        i++;
    }
    return ret && (stack.size() == 0);
}

int main()
{
    cout << scan("else if(is_quote(code[i])){if(stack.size() == 0 || !is_match(stack.top(), code[i])){stack.push(code[i]);}else if(is_match(stack.top(), code[i])){stack.pop();}}") << endl;
    return 0;
}
```