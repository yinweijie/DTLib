1. 栈是先进后出结构，结构示意图为：

![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200525141333.png)


2. 创建`Stack`抽象基类

类关系图为：
![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200525141414.png)

类接口为：

```cpp
template <typename T>
class Stack : public Object
{
public:
    virtual void push(const T& e) = 0;
    virtual void pop() = 0;
    virtual T top() const = 0;
    virtual void clear() = 0;
    virtual int size() const = 0;
};
```

3. 创建`Stack`的子类`StaticStack`

类定义为：

```cpp
template <typename T, int N>
class StaticStack : public Stack<T>
{
protected:
    T m_space[N];
    int m_top;
    int m_size;
public:
    StaticStack()
    {
        m_top = -1;
        m_size = 0;
    }

    int capacity() const
    {
        return N;
    }

    void push(const T& e) override
    {
        if(m_size < N)
        {
            m_space[m_top + 1] = e;
            m_top++;
            m_size++;
        }
        else
        {
            THROW_EXCEPTION(InvalidParameterException, "No space in current stack ...");
        }
    }

    void pop() override
    {
        if(m_size > 0)
        {
            m_top--;
            m_size--;
        }
        else
        {
            THROW_EXCEPTION(InvalidParameterException, "No element in current stack ...");
        }
    }

    T top() const override
    {
        if(m_size > 0)
        {
            return m_space[m_top];
        }
        else
        {
            THROW_EXCEPTION(InvalidParameterException, "No element in current stack ...");
        }
    }

    void clear() override
    {
        m_top = -1;
        m_size = 0;
    }

    int size() const override
    {
        return m_size;
    }
};
```

`push`操作为了保证异常安全，需要先压入元素，再更新`m_top`和`m_size`，因为压入的对象有可能是类，就有可能出现异常。