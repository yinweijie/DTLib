1. 定义`LinkList`类，其接口为：

```cpp
template <typename T>
class LinkList : public List<T>
{
protected:
    struct Node : public Object
    {
        T value;
        Node* next;
    };

    mutable Node m_header;
    int m_length;
public:
    LinkList();

    ...
};
```

这里定义了一个`protected`的内嵌类`Node`，这样做的好处是，只在`LinkList`内被使用，类外部不能直接定义该类型。

2. `LinkList`中的`m_header`需要定义为`mutable`，因为`get`这个`const`函数中有一个赋值语句。

```cpp
Node* current = &m_header;
```

报错为：

```cpp
error: invalid conversion from 'const DTLib::LinkList<Test>::Node*' to 'DTLib::LinkList<Test>::Node*' [-fpermissive]
         Node* current = &m_header;
               ^~~~~~~
```

因为`const`成员函数中`this`指针为`const LinkList<T>* const`类型，因此`this->m_header`为`const LinkList<T>::Node`类型，`&m_header`就为`const LinkList<T>::Node*`类型，出现了不安全的类型转换。

3. 重载一个易于使用的`get`函数，直接返回位置`i`处的数据。

4. 避免在定义链表的时候头结点`m_header`会调用泛型对象`T`的构造函数，将头节点定义由：

```cpp
mutable Node m_header;
```

改写为：
```cpp
mutable struct : public Object// 保证了内存结构与Node类相同，但是m_header的构造不会调用T类型的构造函数，并且要和Node一样，也继承Object
{
    char reserved[sizeof(T)]; // 内存大小与T相同
    Node* next;
} m_header;

...

Node* ret = reinterpret_cast<Node*>(&m_header); // 虽然m_length内存布局与Node相同，但是类型不同，因此需要强制类型转换
```

**注意**：由于`m_header`要转换为`Node`类型，因此内存结构需要完全相同，因此也要继承`Object`。

这样就解决如下隐患：
![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200517161050.png)

直接定义`Node* m_header`不可取，因为在构造函数中是这样初始化的：
```cpp
LinkList()
{
    m_header.next = nullptr;
    m_length = 0;
}
```
如果直接初始化`m_header->next = nullptr`，由于`m_header`本身没有初值，会出现段错误，除非改变更多的初始化逻辑。

5. 增加`position`函数，获取位置`i`的内容。

**注意**：由于`position`函数要被后面的`const`成员函数调用，因此`position`函数也得是`const`函数。

定义为：

```cpp
Node* position(int i) const // 注意这里被后面的const成员函数调用，因此这个函数也必须为const函数
{
    Node* ret = reinterpret_cast<Node*>(&m_header); // 虽然m_length内存布局与Node相同，但是类型不同，因此需要强制类型转换

    for(int p = 0; p < i; p++)
    {
        ret = ret->next;
    }

    return ret;
}
```

代码优化后：
![](https://md-pic-1259272405.cos.ap-guangzhou.myqcloud.com/img/20200517161221.png)

所有左图的操作都被右图的一个函数替代了。

**注意**：最后返回的`current`节点的`next`才是要操作的节点，例如我要操作第0个节点，那么不会进入`for`循环，此时`current`为头结点，而头结点不保存数据，它的`next`节点才是第0个节点。