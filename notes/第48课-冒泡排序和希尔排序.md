1. 冒泡排序

冒泡排序每次从后向前将较小的元素交互到位
冒泡排序是一种稳定的排序法，其复杂度为$O(n^2)$

```cpp
template <typename T>
static void Bubble(T array[], int n, bool min2max = true)
{
    bool exchange = true;

    for(int i = 0; (i < n) && exchange; i++)
    {
        exchange = false;

        for(int j = n - 1; j > i; j--) // 从末尾到i + 1
        {
            if(min2max ? (array[j] < array[j - 1]) : (array[j] > array[j - 1])) // 相邻两两元素对比
            {
                Swap(array[j], array[j - 1]);
                exchange = true; // 如果交换，则做标记，如果都没有交换过，说明后面的元素已经有序
            }
        }
    }
}
```

2. 希尔排序

希尔排序通过分组的方式进行多次插入排序
希尔排序是一种不稳定的排序法，其复杂度为$O(n^{3/2})$

**注**：所谓不稳定，就是指对于相同的元素，在排序后，相对位置可能改变，而稳定排序，则不会改变。

```cpp
template <typename T>
static void Shell(T array[], int n, bool min2max = true) {
    int d = n;

    do
    {
        d = d / 3 + 1; // 工程实践证明，这样的方式减小d的值，能够有效降低时间复杂度

        /* 中间部分为插入排序 */
        for(int i = d; i < n; i+=d) // 第0个元素已经是排序好了的状态，所以从第1个元素开始
        {
            int k = i;
            T e = array[i]; // 把待插入元素拷贝一份

            for(int j = i - d; (j >= 0) && (min2max ? (array[j] > e) : (array[j] < e)); j-=d)
            {
                array[j + d] = array[j]; // 依次往前找是否有比待插入元素大的元素，如果有，就把这个元素往后挪一位，空出这个可能插入的位置
                k = j; // 标记可能插入的位置
            }

            if(k != i) // 如果k == i，说明前面没有比i大的元素，保持不动即可
            {
                array[k] = e; // 把元素i插入到前面合适的位置
            }
        }
        /* 插入排序结束 */
    }
    while(d > 1);
}
```

其思想是，每隔n个元素取一个，进行插入排序，并且这个n逐渐减小到1，因此会进行多轮插入排序。
